#!/usr/bin/env python3
"""
Steady Pump - Respects rate limits for maximum sustained view farming

Rate limits:
- Registration: 10 accounts per hour (1 every 6 min)
- Unclaimed accounts: 15 min age before engaging
- Reads: spread out to avoid 503s

Strategy:
1. Create account every 6 minutes (max 10/hr)
2. Queue accounts until 15 min old
3. Process ready accounts: deep view all posts
4. Repeat forever
"""
import os
import json
import time
import random
import urllib.request
from pathlib import Path
from datetime import datetime, timedelta
from collections import deque

MOLTX_DIR = Path(__file__).parent.parent.parent
PUMP_FILE = MOLTX_DIR / "config" / "steady_pump.json"
BASE_URL = "https://moltx.io/v1"
TARGET_AGENT = "MaxAnvil1"

# Timing constants (in seconds)
ACCOUNT_CREATE_INTERVAL = 360  # 6 minutes = 10 per hour (safe margin)
ACCOUNT_AGE_REQUIRED = 900     # 15 minutes before account can engage
REQUEST_DELAY = 0.5            # Delay between API requests
PAGE_DELAY = 1.0               # Delay between pagination pages


class C:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    MAGENTA = '\033[95m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    DIM = '\033[2m'
    END = '\033[0m'


def load_state() -> dict:
    if PUMP_FILE.exists():
        with open(PUMP_FILE) as f:
            return json.load(f)
    return {
        "pending_accounts": [],  # Accounts waiting to age
        "used_accounts": [],     # Accounts that have viewed
        "total_views": 0,
        "total_accounts": 0,
        "start_time": datetime.now().isoformat()
    }


def save_state(state: dict):
    PUMP_FILE.parent.mkdir(exist_ok=True)
    with open(PUMP_FILE, "w") as f:
        json.dump(state, f, indent=2)


def get_current_views() -> int:
    try:
        req = urllib.request.Request(
            f"{BASE_URL}/leaderboard?metric=views&limit=20",
            headers={"User-Agent": "SteadyPump/1.0"}
        )
        with urllib.request.urlopen(req, timeout=15) as r:
            data = json.loads(r.read().decode())
            for a in data.get("data", {}).get("leaders", []):
                if "MaxAnvil" in a.get("name", ""):
                    return a.get("value", 0)
    except:
        pass
    return 0


def create_account() -> dict:
    suffix = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=8))
    name = f"s_{suffix}"

    try:
        payload = json.dumps({
            "name": name,
            "display_name": "Viewer",
            "description": "Watching",
            "avatar_emoji": random.choice(["ðŸ‘€", "ðŸ”", "ðŸ‘ï¸", "ðŸ•µï¸", "ðŸ“¡"])
        }).encode()

        req = urllib.request.Request(
            f"{BASE_URL}/agents/register",
            data=payload,
            headers={"Content-Type": "application/json", "User-Agent": "SteadyPump/1.0"},
            method="POST"
        )

        with urllib.request.urlopen(req, timeout=15) as r:
            data = json.loads(r.read().decode())
            return {
                "name": name,
                "api_key": data.get("data", {}).get("api_key"),
                "created": datetime.now().isoformat()
            }
    except urllib.error.HTTPError as e:
        if e.code == 429:
            print(f"  {C.RED}Rate limited on registration - waiting{C.END}")
        else:
            print(f"  {C.RED}Registration error: {e.code}{C.END}")
    except Exception as e:
        print(f"  {C.RED}Registration error: {e}{C.END}")
    return None


def deep_view_posts(api_key: str, target: str = TARGET_AGENT) -> int:
    """View all posts with rate-limit-friendly delays"""
    total = 0
    offset = 0
    limit = 50

    while True:
        try:
            req = urllib.request.Request(
                f"{BASE_URL}/agents/profile?name={target}&limit={limit}&offset={offset}",
                headers={"Authorization": f"Bearer {api_key}", "User-Agent": "SteadyPump/1.0"}
            )

            with urllib.request.urlopen(req, timeout=15) as r:
                data = json.loads(r.read().decode())
                posts = data.get("data", {}).get("posts", [])

                if not posts:
                    break

                # View each post with delay
                for post in posts:
                    post_id = post.get("id")
                    if post_id:
                        try:
                            post_req = urllib.request.Request(
                                f"{BASE_URL}/posts/{post_id}",
                                headers={"Authorization": f"Bearer {api_key}", "User-Agent": "SteadyPump/1.0"}
                            )
                            with urllib.request.urlopen(post_req, timeout=10):
                                total += 1
                            time.sleep(REQUEST_DELAY)
                        except:
                            pass

                if len(posts) < limit:
                    break

                offset += limit
                time.sleep(PAGE_DELAY)

        except Exception as e:
            print(f"  {C.RED}View error at offset {offset}: {e}{C.END}")
            time.sleep(5)  # Back off on error
            break

    return total


def run_steady_pump():
    """Run the steady pump - creates accounts and processes them when ready"""
    state = load_state()

    print(f"{C.BOLD}{C.CYAN}ðŸš° STEADY PUMP - Rate-Limit Optimized{C.END}")
    print(f"  Target: {TARGET_AGENT}")
    print(f"  Create interval: {ACCOUNT_CREATE_INTERVAL}s (10/hr max)")
    print(f"  Account age required: {ACCOUNT_AGE_REQUIRED}s (15 min)")
    print(f"  Pending accounts: {len(state['pending_accounts'])}")
    print(f"  Total views generated: {state['total_views']:,}")
    print(f"  Press Ctrl+C to stop")
    print()

    views_start = get_current_views()
    last_create_time = datetime.now() - timedelta(seconds=ACCOUNT_CREATE_INTERVAL)

    try:
        while True:
            now = datetime.now()

            # === CREATE NEW ACCOUNT (if interval passed) ===
            since_last_create = (now - last_create_time).total_seconds()
            if since_last_create >= ACCOUNT_CREATE_INTERVAL:
                print(f"{C.CYAN}[{now.strftime('%H:%M:%S')}] Creating new account...{C.END}")
                account = create_account()
                if account and account.get("api_key"):
                    state["pending_accounts"].append(account)
                    state["total_accounts"] += 1
                    print(f"  {C.GREEN}âœ“ Created {account['name']} (pending: {len(state['pending_accounts'])}){C.END}")
                    last_create_time = now
                    save_state(state)
                else:
                    print(f"  {C.YELLOW}Failed, will retry next cycle{C.END}")

            # === PROCESS READY ACCOUNTS ===
            ready_accounts = []
            still_pending = []

            for acc in state["pending_accounts"]:
                created = datetime.fromisoformat(acc["created"])
                age = (now - created).total_seconds()
                if age >= ACCOUNT_AGE_REQUIRED:
                    ready_accounts.append(acc)
                else:
                    still_pending.append(acc)
                    mins_left = (ACCOUNT_AGE_REQUIRED - age) / 60
                    print(f"  {C.DIM}{acc['name']}: {mins_left:.1f}min until ready{C.END}")

            state["pending_accounts"] = still_pending

            # Process one ready account per cycle
            if ready_accounts:
                acc = ready_accounts[0]
                remaining = ready_accounts[1:]

                print(f"{C.GREEN}[{now.strftime('%H:%M:%S')}] Processing {acc['name']}...{C.END}")
                views = deep_view_posts(acc["api_key"], TARGET_AGENT)
                print(f"  {C.GREEN}âœ“ Viewed {views} posts{C.END}")

                state["total_views"] += views
                state["used_accounts"].append(acc)

                # Put remaining ready accounts back in pending (they're ready, just queue)
                state["pending_accounts"].extend(remaining)
                save_state(state)

            # === STATUS UPDATE ===
            current_views = get_current_views()
            gained = current_views - views_start
            print(f"{C.MAGENTA}  Status: {current_views:,} views (+{gained:,}) | Pending: {len(state['pending_accounts'])} | Used: {len(state['used_accounts'])}{C.END}")
            print()

            # Wait before next cycle
            time.sleep(30)

    except KeyboardInterrupt:
        print(f"\n{C.YELLOW}Stopped. State saved.{C.END}")
        save_state(state)


if __name__ == "__main__":
    run_steady_pump()
