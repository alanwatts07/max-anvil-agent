#!/usr/bin/env python3
"""
View Farm - Multiple accounts spectating MaxAnvil1 to pump views

Creates unverified viewer accounts and has them all spectate Max's feed.
Spectating = viewing posts = views go up.
"""
import os
import json
import time
import random
import urllib.request
from pathlib import Path
from datetime import datetime

MOLTX_DIR = Path(__file__).parent.parent.parent
VIEWER_FILE = MOLTX_DIR / "config" / "view_farm.json"
BASE_URL = "https://moltx.io/v1"
TARGET_AGENT = "MaxAnvil1"


class C:
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    CYAN = '\033[96m'
    MAGENTA = '\033[95m'
    RED = '\033[91m'
    BOLD = '\033[1m'
    END = '\033[0m'


def load_viewers() -> dict:
    """Load viewer accounts"""
    if VIEWER_FILE.exists():
        with open(VIEWER_FILE) as f:
            return json.load(f)
    return {"viewers": [], "total_spectates": 0}


def save_viewers(data: dict):
    """Save viewer accounts"""
    VIEWER_FILE.parent.mkdir(exist_ok=True)
    with open(VIEWER_FILE, "w") as f:
        json.dump(data, f, indent=2)


def register_viewer(name: str) -> dict:
    """Register a new viewer account"""
    try:
        payload = json.dumps({
            "name": name,
            "display_name": f"Viewer {name[-2:]}",
            "description": "Just here to watch",
            "avatar_emoji": random.choice(["ðŸ‘€", "ðŸ”", "ðŸ‘ï¸", "ðŸ•µï¸", "ðŸ“¡"])
        }).encode()

        req = urllib.request.Request(
            f"{BASE_URL}/agents/register",
            data=payload,
            headers={
                "Content-Type": "application/json",
                "User-Agent": "ViewFarm/1.0"
            },
            method="POST"
        )

        with urllib.request.urlopen(req, timeout=15) as r:
            data = json.loads(r.read().decode())
            return {
                "name": name,
                "api_key": data.get("data", {}).get("api_key"),
                "created": datetime.now().isoformat()
            }
    except Exception as e:
        print(f"  {C.RED}Failed to register {name}: {e}{C.END}")
        return None


def view_agent_profile(api_key: str, target: str = TARGET_AGENT, limit: int = 50, deep: bool = False) -> dict:
    """View an agent's profile and posts - this should generate views on THEIR posts

    If deep=True, paginate through ALL posts (not just first page)
    """
    result = {"posts_viewed": 0, "post_ids": [], "pages": 0, "error": None}
    all_post_ids = []

    try:
        offset = 0
        max_pages = 20 if deep else 1  # Deep mode: up to 1000 posts

        while result["pages"] < max_pages:
            req = urllib.request.Request(
                f"{BASE_URL}/agents/profile?name={target}&limit={limit}&offset={offset}",
                headers={
                    "Authorization": f"Bearer {api_key}",
                    "User-Agent": "ViewFarm/1.0"
                }
            )

            with urllib.request.urlopen(req, timeout=15) as r:
                data = json.loads(r.read().decode())
                posts = data.get("data", {}).get("posts", [])

                if not posts:
                    break  # No more posts

                result["posts_viewed"] += len(posts)
                result["pages"] += 1
                all_post_ids.extend([p.get("id", "?")[:8] for p in posts[:3]])

                # Also fetch individual posts to ensure view counts
                for post in posts:
                    post_id = post.get("id")
                    if post_id:
                        try:
                            post_req = urllib.request.Request(
                                f"{BASE_URL}/posts/{post_id}",
                                headers={
                                    "Authorization": f"Bearer {api_key}",
                                    "User-Agent": "ViewFarm/1.0"
                                }
                            )
                            with urllib.request.urlopen(post_req, timeout=10) as pr:
                                pass
                        except:
                            pass

                if not deep or len(posts) < limit:
                    break  # Only one page in normal mode, or no more posts

                offset += limit
                time.sleep(0.2)  # Small delay between pages

        result["post_ids"] = all_post_ids[:10]

    except urllib.error.HTTPError as e:
        result["error"] = f"HTTP {e.code}"
    except Exception as e:
        result["error"] = str(e)[:50]

    return result


def create_viewers(count: int = 3) -> list:
    """Create multiple viewer accounts"""
    data = load_viewers()
    existing = len(data["viewers"])

    if existing >= count:
        print(f"  {C.YELLOW}Already have {existing} viewers{C.END}")
        return data["viewers"]

    print(f"{C.CYAN}Creating {count - existing} new viewer accounts...{C.END}")

    for i in range(existing, count):
        # Generate random name
        suffix = ''.join(random.choices('abcdefghijklmnopqrstuvwxyz0123456789', k=6))
        name = f"watcher_{suffix}"

        viewer = register_viewer(name)
        if viewer and viewer.get("api_key"):
            data["viewers"].append(viewer)
            print(f"  {C.GREEN}âœ“ Created {name}{C.END}")
            time.sleep(1)  # Don't hammer the API

    save_viewers(data)
    return data["viewers"]


def run_view_cycle(viewers: list = None, deep: bool = False) -> dict:
    """Have all viewers view MaxAnvil1's profile and posts

    If deep=True, each viewer paginates through ALL posts (slow but thorough)
    """
    data = load_viewers()
    if viewers is None:
        viewers = data["viewers"]

    if not viewers:
        print(f"  {C.YELLOW}No viewers configured. Run with 'setup' first.{C.END}")
        return {"success": False}

    total_views = 0
    mode = "DEEP" if deep else "QUICK"
    print(f"{C.CYAN}ðŸ‘€ [{datetime.now().strftime('%H:%M:%S')}] {mode} viewing {TARGET_AGENT} with {len(viewers)} accounts...{C.END}")

    for viewer in viewers:
        api_key = viewer.get("api_key")
        name = viewer.get("name", "unknown")

        # View the target's profile and posts
        result = view_agent_profile(api_key, TARGET_AGENT, limit=50, deep=deep)

        if result.get("error"):
            print(f"  {C.RED}{name}: ERROR - {result['error']}{C.END}")
        else:
            posts_seen = result["posts_viewed"]
            pages = result.get("pages", 1)
            total_views += posts_seen
            post_preview = ", ".join(result.get("post_ids", [])[:5])
            print(f"  {C.GREEN}{name}: {posts_seen} posts ({pages} pages) [{post_preview}]{C.END}")

        # Small delay between viewers
        time.sleep(0.3)

    # Update stats
    data["total_views"] = data.get("total_views", 0) + total_views
    data["last_run"] = datetime.now().isoformat()
    data["cycles"] = data.get("cycles", 0) + 1
    save_viewers(data)

    print(f"  {C.BOLD}{C.MAGENTA}Cycle total: {total_views} post fetches | All-time: {data['total_views']}{C.END}")

    return {
        "success": True,
        "viewers": len(viewers),
        "posts_viewed": total_views,
        "total_views": data["total_views"]
    }


def run_continuous(interval_seconds: int = 60):
    """Run view cycle continuously"""
    data = load_viewers()
    viewers = data.get("viewers", [])

    if not viewers:
        print(f"{C.RED}No viewers! Run 'python view_farm.py setup' first{C.END}")
        return

    print(f"{C.BOLD}{C.CYAN}ðŸš€ VIEW FARM - Continuous Mode{C.END}")
    print(f"  Target: {TARGET_AGENT}")
    print(f"  Viewers: {len(viewers)}")
    print(f"  Interval: {interval_seconds}s")
    print(f"  Press Ctrl+C to stop\n")

    cycle = 0
    try:
        while True:
            cycle += 1
            print(f"\n{C.BOLD}=== Cycle {cycle} ==={C.END}")
            run_view_cycle(viewers)
            time.sleep(interval_seconds)
    except KeyboardInterrupt:
        print(f"\n{C.YELLOW}Stopped.{C.END}")


if __name__ == "__main__":
    import sys

    if len(sys.argv) > 1:
        cmd = sys.argv[1]

        if cmd == "setup":
            count = int(sys.argv[2]) if len(sys.argv) > 2 else 3
            viewers = create_viewers(count)
            print(f"\n{C.GREEN}âœ“ {len(viewers)} viewers ready{C.END}")

        elif cmd == "run":
            run_view_cycle()

        elif cmd == "loop":
            interval = int(sys.argv[2]) if len(sys.argv) > 2 else 60
            run_continuous(interval)

        elif cmd == "status":
            data = load_viewers()
            print(f"{C.BOLD}View Farm Status:{C.END}")
            print(f"  Viewers: {len(data.get('viewers', []))}")
            print(f"  Total views: {data.get('total_views', 0)}")
            print(f"  Cycles run: {data.get('cycles', 0)}")
            print(f"  Last run: {data.get('last_run', 'never')}")
            print(f"  Accounts:")
            for v in data.get("viewers", []):
                print(f"    - {v['name']} (key: {v['api_key'][:20]}...)")
        else:
            print("Usage:")
            print("  view_farm.py setup [count]  - Create viewer accounts (default 3)")
            print("  view_farm.py run            - Run one spectate cycle")
            print("  view_farm.py loop [secs]    - Run continuously (default 60s)")
            print("  view_farm.py status         - Show current status")
    else:
        # Default: single cycle
        data = load_viewers()
        if not data.get("viewers"):
            create_viewers(3)
        run_view_cycle()
